# День 1. Программирование на Python


# Занятие 1. Мир ИТ, профессии ИТ


# Занятие 2. Программирование на Python. Структуры данных. 


## Начало работы с Python

### The Zen of Python

```
    Красивое лучше, чем уродливое.
    Явное лучше, чем неявное.
    Простое лучше, чем сложное.
    Сложное лучше, чем запутанное.
    Плоское лучше, чем вложенное.
    Разреженное лучше, чем плотное.
    Читаемость имеет значение.
    Особые случаи не настолько особые, чтобы нарушать правила.
    При этом практичность важнее безупречности.
    Ошибки никогда не должны замалчиваться.
    Если они не замалчиваются явно.
    Встретив двусмысленность, отбрось искушение угадать.
    Должен существовать один и, желательно, только один очевидный способ сделать это.
    Хотя он поначалу может быть и не очевиден, если вы не голландец [^1].
    Сейчас лучше, чем никогда.
    Хотя никогда зачастую лучше, чем прямо сейчас.
    Если реализацию сложно объяснить — идея плоха.
    Если реализацию легко объяснить — идея, возможно, хороша.
    Пространства имён — отличная штука! Будем делать их больше!
```

### Тетрадка Jupyter.

Ячейки с кодом и ячейки с разметкой (markdown).

Запуск кода, смена интерпретатора.

Самое простое, что можно сделать в интерпретаторе Python без знания синтаксиса языка - просто что-то вычислить:


```python
2+2
2*3
3**3
4 + 6 * 7
(4+6)*7
```

Скобки служат для определения приоритета операций.

## Переменные

Переменная - название ячейки памяти, в которой хранится некоторое значение определеного типа. 

```python
a = 2 + 2
a
```

```python
a = 2 + 2
print(a)
```

```python
a = 2 + 2
print(f"{a}")
```

```python
a = 2
b = a + 2
c = b
print(f"{a} {b} {c}")
```


## Типы данных 

### Numbers (числа)

Целые или вещественные.

```python
3.14*2
10/3
```

Можно так же использовать инженерную нотацию для записи вещественных чисел:

```python
1e4
1e-4
100 + 1e2
```

Вещественные числа хранятся с определенной точностью и имеют предел, после которого число становится бесконечностью.

```python
1e400
```


### Strings (строки)

Строки - любой набор символов, даже не печатные и не отображаемые (управляющие).

```python
"Hello world!"
```

```python
"Hello world\nс переносом строки!"
```

Увидели `\n`? Это - перенос строки.

Строки состоят в кодировке Unicode, или UTF-8.

Со строками можно много чего делать.

Можно просто соединять строки ("складывать"):

```python
a = "Hello World"
b = "!"
a + b
```

Взять подстроку:


```python
a = "Hello World!"
a[0:4]
```

Нумерация символов в строках начинается с 0.

Если берется строка с начала, можно опустить 0:

```python
a = "Hello World!"
a[:4]
```

Тоже верно для подстроки до её конца:

```python
a = "Hello World!"
a[6:]
```

Можно заменить подстроку:


```python
a = "Hello World!"
a[6:9] = "Вася"
a
```

Можно без указания индекса подстроки:


```python
a = "Hello World!"
b = "World"
c = "Вася"
a.replace(b,c)
```


Можно убрать пробелы по краям строк (если они там есть):


```python
a = "   Hello World!   "
a.strip()
```

Можно привести строку к верхнему регистру:

```python
a = "   hello world!   "
a.upper()
```

Попробуйте сами применить методы `lower()`, `capitalize()`, `title()`

А еще строку можно разбить на части:

```python
a = "Hello World"
a.split()
```

и с этим мы удачно подошли к спискам 

### Lists (списки) и циклы

Список это упорядоченный набор элементов

```python
a = ['Hello', 'World']
a
```

Список не обязательно состоит из элементов одного типа, хотя на практике чаще всего в списке однотипные элементы.

Обращаться к элементам списка можно так же как и к подстрокам:


```python
a = ['Hello', 'World']
print(a)
print(a[0])
print(a[1:])
```

Можно добавить новый элемент списка:

```python
a.append("!")
a
```

```python
b = ['and', 'stuff']
a.extend(b)
a
```

#### Проход по списку (итерация)

для прохода по списку в языке предусмотрены циклы. *Тело цикла* выполняется столько раз, сколько элементов в списке, а
 *переменной цикла* `element` присваивается эначение текущего элемента.

```python
hello_list = ['Hello', 'World'] + ['and', 'stuff']

for element in hello_list:
   print(i)
```

Отступ неодходим, причем строки тела цикла все должны быть с одним отступом. Сколько пробелов в отступе не имеет значения. Как называется переменная цикла тоже не имеет значения.

Пример с суммированием элементов списка:


```python
hello_list = [1,2,3,5]

sum = 0 #начальное значение суммы.

for i in hello_list:
   sum = sum + i
   
print(i)
```

Заметили #? Это комментарий. Питон не пытается интерпретировать текст после # как программу. Можно (нужно) писать о том что делает ваш код.

А еще есть такая штука, которая называется `списковое включение`, или `генератор списка`:

```python
a_list = [1,2,3,4,5]

b_list = [ x*2 for x in a_list ]
```

Второй список будет содержать элементы первого списка, умноженные на 2. Это идиома питона, чтобы заменить короткий цикл одной строкой.

### Dictionaries (словари)

Словарь - это набор пар ключ-значение. Отличие от списка в том, что элементы словаря можно извлечь не по индексу элемента в списке, а по ключу этого элемента. По аналогии со словарем-книгой, где мы ищем описание (перевод) по ключевому слову. Ключи уникальные.

```python
d = {"имя": "Алексей", "возраст": 14, "город": "Москва", "школа": 1}

print(d)
print(d["имя"])
print(f'Привет, {d["имя"]}')
```

Заметили разные кавычки?

#### Проход по словарю (итерация)

```
for key, value in d.items():
   print(f"Ключ {key} значение {value}"
   print(d[key])

Заметили, что порядок элементов такой же, как задавали при создании словаря? Это так в последних версиях питона, но не свойства этого типа данных в целом.
```

А что за новый синтакс с запятой? `key, value`? Это кортеж.

### Tuples (кортежи)

Это упорядоченный набор элементов, который нельзя изменить. Из-за этого с ним мало что можно делать. 

### Sets (множества)

Неупорядоченный набор элементов, с которым можно делать  операции теории множеств.

### Boolean (логический тип данных) и условные операторы

Как часто вы слышите в споре "Истина где-то посередине"? У компьютера так не бывает. Компьютеры работают с двоичной системой счисления, в которой есть только 0 или 1. Соответственно, у компьютеров бинарная логика - либо 0, либо 1. Единице соответствует истина (True), а нулю - ложь (False).

Применение в Python.

```python
a = 2
b = 4
print(a < b)
print(a > b)
print(a == b)
```

Поиграйте с ">=", "<=", "!="

Проверять условие и что-то делать в зависимости от результата можно с помощью условных операторов.

```python
if a > b:
  print(f"{a} is indeed greater then {b}")
```

```python
if a > b:
  print(f"{a} is indeed greater then {b}")
else:
  print(f"{a} is NOT greater then {b}")
```

```python
if a > b:
  print(f"{a} is indeed greater then {b}")
elif a < b:
  print(f"{a} is less then {b}")
else: 
  print(f"{a} is equal to {b}")
```


### Справочник по типам данных

https://digitology.tech/docs/python_3/library/stdtypes.html

Гуглите, не стесняйтесь! Обращайте внимание на stackoverflow.com 



# Занятие 3. Программирование на Python. Алгоритмы.

Что такое алгоритм. Почему важны алгоритмы.

## Алгоритмы сортировки

### Пузырьковый метод

1. Сравниваются два соседних элемента списка. Если первый больше второго, то они меняются местами. Повторяем для последующих пар, пока не пройдем весь список. После первого прохода возвращаемся к началу списка и начинаем попарные сравнения 

Задание: Реализуйте алгоритм сортировки пузырьковым методом.

1. Реализуйте обмен двух переменных значениями. 
2. Задайте список с случайными числами. Реализуйте цикл прохода по списку, в теле которого выполняется обмен значениями.
3. Реализуйте условия окончания сортировки и вывод отсортированного списка.

Сравните быстродействие вашего алгоритма и встроенной функции sorted(), используя прагму %%time в ячейке

Вопрос - сколько проходов делает алгоритм по списку?

О-нотация

## Алгоритмы поиска

Нахождение элемента в списке или других структурах. 

### Линейный поиск

Алгоритм проходит по списку, сравнивая каждый элемент списка с заданным элементом и возвращает индекс найденного в списке элемента или None если такого элемента в списке нет.

Реализуйте алгоритм линейного поиска:
Задайте список
Задайте элемент для поиска.
Задайте переменную для ответа.

Реализуйте проход по списку и сравнение текущего элемента с заданным элементом. При совпадении, присвоить переменной для ответа индекс (номер) текущего элемента и прекратите поиск.
Выведите значение переменной для ответа.

Проверьте алгоритм для нескольких случаев:
* искомый элемент первый в списке
* искомый элемент последний в списке
* искомый элемент где-то посередине
* искомого элемента нет в списке.

Примените все эти варианты искомого элемента для следующих вариантов списка:
* список состоит из одного элемента
* список пустой (0 элементов)

Проверьте быстродействие вашего алгоритма в сравнении с оператором `in`.

### Бинарный поиск

Применяется к отсортированным спискам. 

Работа алгоритма:

* Определяется длина списка
* Вычисляется индек элемента посередине списка (или почти посередине).
* Если он меньше искомого, то продолжаем поиск только среди элементов "справа" от среднего элемента.
* И так пока искомы элемент не найден или список для поиска не станет пустым. 

Проверьте алгоритм тестами из линейного поиска.

Сравните скорость работы бинарного алгоритма, линейного и оператора `in`.


# Лекция - Что такое искусственный интеллект


# Мастер-класс - Генерация картинок

ru-dalle.ru

t.me/rudalle

TODO COLAB

